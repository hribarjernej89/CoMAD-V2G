import simpy
import numpy as np

DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]  # This is a non-leap year( data is 2022 and 2023)


class SharedBattery:
    """ Battery Shared by the community of households with PV, and V2Gs.
    The main idea is to store excess energy generated by the household is stored here for later usage """
    def __init__(self, unique_id, num_households, timestep_size=0.25, battery_cap=50, min_battery_cap=.05,
                 max_battery_cap=.95, init_battery_percentage=.5, battery_charge_power=20,
                 shared_bat_charge_efficiency=.95, shared_bat_discharge_efficiency=.95, power_line_charge_efficiency=.95,
                 power_line_discharge_efficiency=.95, train=False):

        self.unique_id = unique_id
        self.num_households = num_households
        # To collect information correctly
        self.timestep_size = timestep_size  # time step size in hours
        # Shared battery parameters
        self.battery_cap = battery_cap  # Capacity of the Shared battery in kWh
        self.battery_energy_percentage = init_battery_percentage  # The initial energy the battery has
        self.battery_energy = self.battery_cap * self.battery_energy_percentage  # Starting energy the shared battery
        self.min_bat_cap = min_battery_cap  # The min battery capacity we allow in percentage
        self.max_bat_cap = max_battery_cap  # The max battery capacity we allow before we start selling in percentage
        #print("Max battery capacity", self.max_bat_cap)
        self.shared_bat_charge_efficiency = shared_bat_charge_efficiency  # Efficiency of charging the battery
        self.shared_bat_discharge_efficiency = shared_bat_discharge_efficiency  # Efficiency of discharging  the battery

        # parameters to measure performance, we start on January first at 00:01, if not change accordingly
        self.current_month = 0
        self.day_in_a_month = 0
        self.day_time_step_len = int(24 / self.timestep_size)
        self.train = train  # If True, the system trains the agents
        # Reading real value from a file, save it to the
        if self.train:
            # Using comed price hour mean
            self.energy_price_file = open('energy_price/polar_price_hour_mean_2022.csv', 'r')   # hourly price change
        else:
            self.energy_price_file = open('energy_price/polar_price_hour_mean_2023.csv', 'r')  # hourly price change
        self.energy_price = self.energy_price_file.readlines()
        self.energy_price_line = 1  # The line we are reading
        self.energy_price_values = self.energy_price[self.energy_price_line]
        self.sell_energy_price = np.round(float(self.energy_price_values.split(',')[3]) / 1000, 5)  # euro per kWhs
        self.buy_energy_price = np.round(float(self.energy_price_values.split(',')[4]) / 1000, 5)  # euro per kWhs
        print("Energy prices at Shared Battery:", self.sell_energy_price, self.buy_energy_price)
        self.battery_energy_step_cost = 0  # The exchange in euros, what we need to track
        # Tracking energy exchange
        self.energy_exchange_in_timestep = []
        self.energy_difference = 0
        self.community_exchange_with_grid = 0
        # Exchange of energy with the power grid
        self.power_line_charge_efficiency = power_line_charge_efficiency
        self.power_line_discharge_efficiency = power_line_discharge_efficiency
        self.battery_charge_power = battery_charge_power
        self.max_battery_charge_energy = self.battery_charge_power * self.timestep_size  # in kWh
        self.bat_life_cycles = 0.0  # Measuring Number of charging cycles
        self.bat_life_cycles_list = []

        # We want to measure how much battery the community battery receives over month
        self.temp_energy_difference = []
        self.daily_energy_difference = []
        self.monthly_energy_difference = []
        # How much energy is given to the external grid
        self.temp_external_grid_diff_pos = [0]
        self.daily_external_grid_diff_pos = []
        self.monthly_external_grid_diff_pos = []
        # How much money is earned by trading with the grid
        self.temp_energy_sell = [0]
        self.daily_energy_sell = []
        self.monthly_energy_sell = []
        # How much energy is given taken from the external grid
        self.temp_external_grid_diff_neg = [0]
        self.daily_external_grid_diff_neg = []
        self.monthly_external_grid_diff_neg = []
        # How much money is spent buying the energy
        self.temp_energy_buy = [0]
        self.daily_energy_buy = []
        self.monthly_energy_buy = []

    def charge_or_discharge(self, env, community_power_line):
        """
        In this process, we charge or discharge the community battery.
        """
        while True:  # Set to True as the Server is always checking for status updates
            # Get event from channel
            # self.energy_exchange_in_timestep = []
            energy = yield community_power_line.energy_from_households()
            self.energy_exchange_in_timestep.append(energy)
            # We need to wait to get information about energy consumption from every household, did better below
            # if len(self.energy_exchange_in_timestep) == self.num_households:
            #    print("Total energy consumption at time", env.now, "is", np.sum(self.energy_exchange_in_timestep))

    def local_grid_energy_exchange(self, env):
        """
        In this process, we exchange the energy with the rest of the community!
        """
        while True:
            yield env.timeout(1)
            # First we check how much energy was exchanged in the timestep
            # print("Energy exchanged in timestep", self.energy_exchange_in_timestep)
            self.energy_difference = np.sum(self.energy_exchange_in_timestep)
            # print("Total energy difference", self.energy_difference)
            # Tracking energy difference
            self.temp_energy_difference.append(self.energy_difference)
            self.energy_exchange_in_timestep = []

    def dynamic_energy_price_change(self, env):
        """
        Read from the file to update the price of
        """
        while True:
            yield env.timeout(int(1/self.timestep_size))  # In each time step we update the tou price of electricity
            self.energy_price_values = self.energy_price[self.energy_price_line]
            self.sell_energy_price = np.round(float(self.energy_price_values.split(',')[3]) / 1000, 5)  # euro per kWhs
            self.buy_energy_price = np.round(float(self.energy_price_values.split(',')[4]) / 1000, 5)  # euro per kWhs
            self.energy_price_line += 1  # The line we are reading in next step

    def energy_in_battery(self, env):
        """
        Process to charge or discharge the community battery, by selling or buying the energy from the grid whenever,
        the amount of available energy if too low (DOWN LIMIT) or too high (UPPER LIMIT)!!!
        """
        while True:
            yield env.timeout(1)
            self.community_exchange_with_grid = 0
            if self.energy_difference >= 0.0:  # if exchanged energy is positive we can charge and/or sell energy
                if self.energy_difference <= (self.max_battery_charge_energy / self.shared_bat_charge_efficiency) and self.battery_energy_percentage < self.max_bat_cap: # Charge entire exchanged energy to the community battery
                    self.battery_energy = self.battery_energy + (self.energy_difference / self.shared_bat_charge_efficiency)
                    self.battery_energy_percentage = np.round(self.battery_energy / self.battery_cap, 4)
                    self.temp_external_grid_diff_pos.append(0)  # to make sure list is not empty
                    self.bat_life_cycles += np.round((self.energy_difference / self.shared_bat_charge_efficiency) / self.battery_cap, 4)
                    self.battery_energy_step_cost = 0
                    self.temp_energy_sell.append(self.battery_energy_step_cost)
                    #      self.battery_energy_percentage, "amount in kWh: ", self.battery_energy)
                elif self.energy_difference >= (self.max_battery_charge_energy / self.shared_bat_charge_efficiency) and self.battery_energy_percentage < self.max_bat_cap: # Charge the battery as much as you can, sell the rest of the energy
                    self.battery_energy = self.battery_energy + self.max_battery_charge_energy
                    self.battery_energy_percentage = np.round(self.battery_energy / self.battery_cap, 4)
                    self.bat_life_cycles += np.round((self.max_battery_charge_energy / self.shared_bat_charge_efficiency) / self.battery_cap, 4)
                    # We sell excess energy, also track energy exchange with the external grid
                    self.community_exchange_with_grid = self.energy_difference - (self.max_battery_charge_energy / self.shared_bat_charge_efficiency)
                    self.temp_external_grid_diff_pos.append(self.community_exchange_with_grid)
                    self.battery_energy_step_cost = self.community_exchange_with_grid * self.sell_energy_price
                    self.temp_energy_sell.append(self.battery_energy_step_cost)
                elif self.battery_energy_percentage >= self.max_bat_cap:  # Battery is full and sells the excess energy
                    self.community_exchange_with_grid = self.energy_difference
                    self.temp_external_grid_diff_pos.append(self.community_exchange_with_grid)
                    self.battery_energy_step_cost = self.community_exchange_with_grid * self.sell_energy_price
                    self.temp_energy_sell.append(self.battery_energy_step_cost)
                else:
                    print("INVALID BATTERY CHARGE OPTION!!")
            else:  # exchanged energy is negative and we need to discharge and/or buy energy
                if np.abs(self.energy_difference) <= (self.max_battery_charge_energy * self.shared_bat_discharge_efficiency) and self.battery_energy_percentage > self.min_bat_cap:  # Take entire required energy from the community battery
                    self.battery_energy = self.battery_energy + (self.energy_difference / self.shared_bat_discharge_efficiency)
                    self.battery_energy_percentage = np.round(self.battery_energy / self.battery_cap, 4)
                    self.temp_external_grid_diff_neg.append(0)  # to make sure list is not empty
                    self.battery_energy_step_cost = 0
                    self.temp_energy_buy.append(self.battery_energy_step_cost )
                elif np.abs(self.energy_difference) >= (self.max_battery_charge_energy * self.shared_bat_discharge_efficiency) and self.battery_energy_percentage > self.min_bat_cap:  # Take as much energy as possible from the battery and buy the rest
                    self.battery_energy = self.battery_energy - (
                                self.max_battery_charge_energy / self.shared_bat_discharge_efficiency)
                    self.battery_energy_percentage = np.round(self.battery_energy / self.battery_cap, 4)
                    # We buy the test of the energy we need
                    self.community_exchange_with_grid = self.energy_difference + self.max_battery_charge_energy # Here we have a plus to avoid double negative
                    self.temp_external_grid_diff_neg.append(self.community_exchange_with_grid )
                    self.battery_energy_step_cost = self.community_exchange_with_grid * self.buy_energy_price
                    self.temp_energy_buy.append(self.battery_energy_step_cost )
                elif self.battery_energy_percentage <= self.min_bat_cap:  # The battery is empty, buy the energy we need
                    self.community_exchange_with_grid = self.energy_difference  #
                    self.temp_external_grid_diff_neg.append(self.community_exchange_with_grid)
                    self.battery_energy_step_cost = self.community_exchange_with_grid * self.buy_energy_price
                    self.temp_energy_buy.append(self.battery_energy_step_cost)
                else:
                    print("INVALID BATTERY DISCHARGE OPTION!!")

    def collect_simulation_data(self, env):
        """
        Process that will collect, data daily, monthly
        """
        while True:
            yield env.timeout(self.day_time_step_len)
            # sum daily temp values
            self.daily_energy_difference.append(np.sum(self.temp_energy_difference))
            self.daily_external_grid_diff_pos.append(np.sum(self.temp_external_grid_diff_pos))
            self.daily_external_grid_diff_neg.append(np.sum(self.temp_external_grid_diff_neg))
            self.daily_energy_sell.append(np.sum(self.temp_energy_sell))
            self.daily_energy_buy.append(np.sum(self.temp_energy_buy))
            # empty the temporal daily lists
            self.temp_energy_difference = [0]
            self.temp_external_grid_diff_pos = [0]
            self.temp_external_grid_diff_neg = [0]
            self.temp_energy_sell = [0]
            self.temp_energy_buy = [0]
            # check if this is end of the month
            self.day_in_a_month += 1
            if self.day_in_a_month == DAYS_IN_MONTH[self.current_month % 12]:
                #print("Maximal and minimal in a month energy exchange of energy:", max(self.daily_energy_difference),
                #      min(self.daily_energy_difference))
                self.monthly_energy_difference.append(sum(self.daily_energy_difference))
                self.monthly_external_grid_diff_pos.append(sum(self.daily_external_grid_diff_pos))
                self.monthly_external_grid_diff_neg.append(sum(self.daily_external_grid_diff_neg))
                self.monthly_energy_sell.append(sum(self.daily_energy_sell))
                self.monthly_energy_buy.append(sum(self.daily_energy_buy))
                self.bat_life_cycles_list.append( self.bat_life_cycles)

                self.day_in_a_month = 0
                self.current_month += 1
                print("Shared Battery INFO!")
                print("Monthly energy exchanged internally:", self.monthly_energy_difference,
                      "Monthly energy transferred to the grid:", self.monthly_external_grid_diff_pos,
                      "Monthly energy transferred from the grid:", self.monthly_external_grid_diff_neg,
                      "Monthly energy transfer:",
                      [x + y for x, y in zip(self.monthly_external_grid_diff_pos, self.monthly_external_grid_diff_neg)],
                      "Cost of energy in Euros combined:",
                      [x + y for x, y in zip(self.monthly_energy_sell, self.monthly_energy_buy)],
                      "Sell in Euros:", self.monthly_energy_sell,
                      "Buy in Euros:", self.monthly_energy_buy,
                      "Battery Life cycles:", self.bat_life_cycles)
                # empty daily values
                self.daily_energy_difference = []
                self.daily_external_grid_diff_pos = []
                self.daily_external_grid_diff_neg = []
                self.daily_energy_sell = []
                self.daily_energy_buy = []

